//! Bindings to NGINX
//! This project provides Rust SDK interfaces to the [NGINX](https://nginx.com) proxy allowing the creation of NGINX
//! dynamic modules completely in Rust.
//!
//! ## Build
//!
//! NGINX modules can be built against a particular version of NGINX. The following environment variables can be used
//! to specify a particular version of NGINX or an NGINX dependency:
//!
//! * `ZLIB_VERSION` (default 1.3.1) - zlib version
//! * `PCRE2_VERSION` (default 10.42 for NGINX 1.22.0 and later, or 8.45 for earlier) - PCRE1 or PCRE2 version
//! * `OPENSSL_VERSION` (default 3.2.1 for NGINX 1.22.0 and later, or 1.1.1w for earlier) - OpenSSL version
//! * `NGX_VERSION` (default 1.26.1) - NGINX OSS version
//! * `NGX_DEBUG` (default to false) -  if set to true, then will compile NGINX `--with-debug` option
//!
//! For example, this is how you would compile the [examples](https://github.com/nginxinc/ngx-rust/tree/master/examples) using a specific version of NGINX and enabling
//! debugging: `NGX_DEBUG=true NGX_VERSION=1.23.0 cargo build --package=examples --examples --release`
//!
//! To build Linux-only modules, use the "linux" feature: `cargo build --package=examples --examples --features=linux --release`
//!
//! After compilation, the modules can be found in the path `target/release/examples/` ( with the `.so` file extension for
//! Linux or `.dylib` for MacOS).
//!
//! Additionally, the folder  `.cache/nginx/{NGX_VERSION}/{OS}/` will contain the compiled version of NGINX used to build
//! the SDK. You can start NGINX directly from this directory if you want to test the module or add it to `$PATH`
//! ```not_rust
//! $ export NGX_VERSION=1.23.3
//! $ cargo build --package=examples --examples --features=linux --release
//! $ export PATH=$PATH:`pwd`/.cache/nginx/$NGX_VERSION/macos-x86_64/sbin
//! $ nginx -V
//! $ ls -la ./target/release/examples/
//! # now you can use dynamic modules with the NGINX
//! ```

#![warn(missing_docs)]
/// The core module.
///
/// This module provides fundamental utilities needed to interface with many NGINX primitives.
/// String conversions, the pool (memory interface) object, and buffer APIs are covered here. These
/// utilities will generally align with the NGINX 'core' files and APIs.
pub mod core;

/// The ffi module.
///
/// This module provides scoped FFI bindings for NGINX symbols.
pub mod ffi;

/// The http module.
///
/// This modules provides wrappers and utilities to NGINX http APIs, such as requests,
/// configuration access, and statuses.
pub mod http;

/// The log module.
///
/// This module provides an interface into the NGINX logger framework.
pub mod log;

use nginx_sys::ngx_str_t;
/// Re-export paste module for macros.
pub use paste;

#[macro_export]
macro_rules! http_module {
    ($module:ty, $([$command:expr, $handler:ident]),*) => {
        $crate::paste::paste! {
            #[no_mangle]
            #[allow(non_upper_case_globals)]
            static [<__module_ctx_ $module>]: ngx_http_module_t = $crate::module_context!($module);

            #[no_mangle]
            #[allow(non_upper_case_globals)]
            static mut [<__module_commands_ $module>]: [ngx_command_t; $crate::count!($($command,)*) + 1] = $crate::commands!($($command,)*);
        }
    };
}

/// Define the module context.
#[macro_export]
macro_rules! module_context {
    ($module:ty) => {
        $crate::ffi::ngx_http_module_t {
            preconfiguration: Some(<$module as $crate::http::HTTPModule>::preconfiguration),
            postconfiguration: Some(<$module as $crate::http::HTTPModule>::postconfiguration),
            create_main_conf: Some(<$module as $crate::http::HTTPModule>::create_main_conf),
            init_main_conf: Some(<$module as $crate::http::HTTPModule>::init_main_conf),
            create_srv_conf: Some(<$module as $crate::http::HTTPModule>::create_srv_conf),
            merge_srv_conf: Some(<$module as $crate::http::HTTPModule>::merge_srv_conf),
            create_loc_conf: Some(<$module as $crate::http::HTTPModule>::create_loc_conf),
            merge_loc_conf: Some(<$module as $crate::http::HTTPModule>::merge_loc_conf),
        }
    };
}

/// Define modules exported by this library.
///
/// These are normally generated by the Nginx module system, but need to be
/// defined when building modules outside of it.
#[macro_export]
macro_rules! ngx_modules {
    ($( $mod:ident ),+) => {
        #[no_mangle]
        #[allow(non_upper_case_globals)]
        pub static mut ngx_modules: [*const ngx_module_t; $crate::count!($( $mod, )+) + 1] = [
            $( unsafe { &$mod } as *const ngx_module_t, )+
            std::ptr::null()
        ];

        #[no_mangle]
        #[allow(non_upper_case_globals)]
        pub static mut ngx_module_names: [*const c_char; $crate::count!($( $mod, )+) + 1] = [
            $( concat!(stringify!($mod), "\0").as_ptr() as *const c_char, )+
            std::ptr::null()
        ];

        #[no_mangle]
        #[allow(non_upper_case_globals)]
        pub static mut ngx_module_order: [*const c_char; 1] = [
            std::ptr::null()
        ];
    };
}

pub fn set_no_op<T>(_cf: &mut T, _args: &[ngx_str_t]) -> Result<(), ()> {
    Ok(())
}

#[macro_export]
macro_rules! command {
    ($module:ty, $conf:tt, $builder:expr) => {{
        type ConfType = <$module as $crate::http::SafeHttpModule>::$conf;

        const BUILDER: CommandBuilder<ConfType> = $builder;

        $crate::paste::paste! {
            #[allow(non_snake_case)]
            unsafe extern "C" fn [<__raw_c_handler_ $conf>](
                cf: *mut ngx_conf_t,
                _cmd: *mut ngx_command_t,
                conf: *mut c_void,
            ) -> *mut c_char {
                const HANDLER: fn(&mut ConfType, &[ngx_str_t]) -> Result<(), ()> =
                    if let Some(handler) = BUILDER.handler() {
                        handler
                    } else {
                        $crate::set_no_op
                    };

                let conf = unsafe { (conf as *mut ConfType).as_mut() }.unwrap();
                let args = unsafe { Array::<ngx_str_t>::new_raw((*cf).args) }.unwrap();
                let args = &args[1..];

                let output: Result<(), ()> = HANDLER(conf, args);

                if output.is_ok() {
                    $crate::core::NGX_CONF_OK as _
                } else {
                    $crate::core::NGX_CONF_ERROR as _
                }
            }
        }

        let mut built = BUILDER.build_partial();

        $crate::paste::paste! {
            if BUILDER.handler().is_some() {
                built.set = Some([<__raw_c_handler_ $conf>]);
            }
        }

        built.conf = $crate::command!(offset: $conf).into_conf_offset();

        built
    }};

    (offset: MainConf) => {
        $crate::http::ConfOffset::Main
    };

    (offset: LocConf) => {
        $crate::http::ConfOffset::Loc
    };

    (offset: SrvConf) => {
        $crate::http::ConfOffset::Srv
    };
}

/// Count number of arguments
#[macro_export]
macro_rules! count {
    () => { 0usize };
    ($x:tt, $( $xs:tt ),*) => { 1usize + $crate::count!($( $xs, )*) };
}
