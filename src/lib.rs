//! Bindings to NGINX
//! This project provides Rust SDK interfaces to the [NGINX](https://nginx.com) proxy allowing the creation of NGINX
//! dynamic modules completely in Rust.
//!
//! ## Build
//!
//! NGINX modules can be built against a particular version of NGINX. The following environment variables can be used
//! to specify a particular version of NGINX or an NGINX dependency:
//!
//! * `ZLIB_VERSION` (default 1.3.1) - zlib version
//! * `PCRE2_VERSION` (default 10.42 for NGINX 1.22.0 and later, or 8.45 for earlier) - PCRE1 or PCRE2 version
//! * `OPENSSL_VERSION` (default 3.2.1 for NGINX 1.22.0 and later, or 1.1.1w for earlier) - OpenSSL version
//! * `NGX_VERSION` (default 1.26.1) - NGINX OSS version
//! * `NGX_DEBUG` (default to false) -  if set to true, then will compile NGINX `--with-debug` option
//!
//! For example, this is how you would compile the [examples](https://github.com/nginxinc/ngx-rust/tree/master/examples) using a specific version of NGINX and enabling
//! debugging: `NGX_DEBUG=true NGX_VERSION=1.23.0 cargo build --package=examples --examples --release`
//!
//! To build Linux-only modules, use the "linux" feature: `cargo build --package=examples --examples --features=linux --release`
//!
//! After compilation, the modules can be found in the path `target/release/examples/` ( with the `.so` file extension for
//! Linux or `.dylib` for MacOS).
//!
//! Additionally, the folder  `.cache/nginx/{NGX_VERSION}/{OS}/` will contain the compiled version of NGINX used to build
//! the SDK. You can start NGINX directly from this directory if you want to test the module or add it to `$PATH`
//! ```not_rust
//! $ export NGX_VERSION=1.23.3
//! $ cargo build --package=examples --examples --features=linux --release
//! $ export PATH=$PATH:`pwd`/.cache/nginx/$NGX_VERSION/macos-x86_64/sbin
//! $ nginx -V
//! $ ls -la ./target/release/examples/
//! # now you can use dynamic modules with the NGINX
//! ```

#![warn(missing_docs)]
/// The core module.
///
/// This module provides fundamental utilities needed to interface with many NGINX primitives.
/// String conversions, the pool (memory interface) object, and buffer APIs are covered here. These
/// utilities will generally align with the NGINX 'core' files and APIs.
pub mod core;

/// The ffi module.
///
/// This module provides scoped FFI bindings for NGINX symbols.
pub mod ffi;

/// The http module.
///
/// This modules provides wrappers and utilities to NGINX http APIs, such as requests,
/// configuration access, and statuses.
pub mod http;

/// The log module.
///
/// This module provides an interface into the NGINX logger framework.
pub mod log;

/// Define modules exported by this library.
///
/// These are normally generated by the Nginx module system, but need to be
/// defined when building modules outside of it.
#[macro_export]
macro_rules! ngx_modules {
    ($( $mod:ident ),+) => {
        #[no_mangle]
        #[allow(non_upper_case_globals)]
        pub static mut ngx_modules: [*const ngx_module_t; $crate::count!($( $mod, )+) + 1] = [
            $( unsafe { &$mod } as *const ngx_module_t, )+
            std::ptr::null()
        ];

        #[no_mangle]
        #[allow(non_upper_case_globals)]
        pub static mut ngx_module_names: [*const c_char; $crate::count!($( $mod, )+) + 1] = [
            $( concat!(stringify!($mod), "\0").as_ptr() as *const c_char, )+
            std::ptr::null()
        ];

        #[no_mangle]
        #[allow(non_upper_case_globals)]
        pub static mut ngx_module_order: [*const c_char; 1] = [
            std::ptr::null()
        ];
    };
}

/// Set up the context, http module definition and module definition for a HTTP module.
///
/// This macro takes a [`HTTPModule`](crate::http::HTTPModule) as first argument, and
/// an array of `{MainConf, SrvConf, LocConf}`: [`Command`](crate::http::Command)s as commands.
#[macro_export]
macro_rules! http_module_conf {
    ($module:ty, [$($ty:tt: $command:expr),*]) => {{
        #[used]
        static mut COMMANDS: [ngx::ffi::ngx_command_t; $crate::count!($($command,)*) + 1] = [
            $(
                $crate::command!($module, $ty, $command),
            )*
            $crate::ngx_null_command!(),
        ];

        #[used]
        static mut HTTP_MODULE: ngx::ffi::ngx_http_module_t = ngx::ffi::ngx_http_module_t {
            preconfiguration: Some(<$module as ngx::http::HTTPModule>::preconfiguration),
            postconfiguration: Some(<$module as ngx::http::HTTPModule>::postconfiguration),
            create_main_conf: Some(<$module as ngx::http::HTTPModule>::create_main_conf),
            init_main_conf: Some(<$module as ngx::http::HTTPModule>::init_main_conf),
            create_srv_conf: Some(<$module as ngx::http::HTTPModule>::create_srv_conf),
            merge_srv_conf: Some(<$module as ngx::http::HTTPModule>::merge_srv_conf),
            create_loc_conf: Some(<$module as ngx::http::HTTPModule>::create_loc_conf),
            merge_loc_conf: Some(<$module as ngx::http::HTTPModule>::merge_loc_conf),
        };

        #[used]
        pub static mut MODULE: ngx_module_t = ngx_module_t {
            ctx_index: ngx_uint_t::MAX,
            index: ngx_uint_t::MAX,
            name: std::ptr::null_mut(),
            spare0: 0,
            spare1: 0,
            version: ngx::ffi::nginx_version as ngx_uint_t,
            signature: ngx::ffi::NGX_RS_MODULE_SIGNATURE.as_ptr() as _,

            ctx: unsafe { std::ptr::addr_of_mut!(HTTP_MODULE) } as _,
            commands: unsafe { std::ptr::addr_of_mut!(COMMANDS) } as _,
            type_: ngx::ffi::NGX_HTTP_MODULE as ngx_uint_t,

            init_master: None,
            init_module: None,
            init_process: None,
            init_thread: None,
            exit_thread: None,
            exit_process: None,
            exit_master: None,

            spare_hook0: 0,
            spare_hook1: 0,
            spare_hook2: 0,
            spare_hook3: 0,
            spare_hook4: 0,
            spare_hook5: 0,
            spare_hook6: 0,
            spare_hook7: 0,
        };

        unsafe { MODULE }
    }};
}

/// Count number of arguments
#[macro_export]
macro_rules! count {
    () => { 0usize };
    ($x:tt, $( $xs:tt ),*) => { 1usize + $crate::count!($( $xs, )*) };
}
